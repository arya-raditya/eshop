Name    : Arya Raditya Kusuma

NPM     : 2306215816

Class    : B

# Reflection 1: Coding Standards and Secure Coding
## You already implemented two new features using Spring Boot. Check again your source code and evaluate the coding standards that you have learned in this module. Write clean code principles and secure coding practices that have been applied to your code.  If you find any mistake in your source code, please explain how to improve your code

Throughout this assignment, I've consciously tried to implement several clean code principles and secure coding practices, although reviewing the code now reveals areas for improvement. For instance, I made sure to use descriptive variable and method names (e.g., productRepository, findById) to improve readability and maintainability. I also attempted to keep methods relatively short and focused on a single responsibility. However, I notice now that some of the if statement blocks within the repository methods, particularly in update and delete, could be extracted into separate helper functions to enhance code clarity. Regarding security, while this assignment didn't directly involve handling sensitive user data, I've incorporated input validation best practices in other Spring Boot projects, and recognize that we need to extend it here to anticipate all edge cases of product name and quantity, preventing potential exceptions later on. This would prevent common vulnerabilities and improve the overall robustness of the application. 

# Reflection 2: Unit Test and Functional Test
## After writing the unit test, how do you feel? How many unit tests should be made in a class? How to make sure that our unit tests are enough to verify our program? It would be good if you learned about code coverage. Code coverage is a metric that can help you understand how much of your source is tested. If you have 100% code coverage, does that mean your code has no bugs or errors? 

After writing the unit tests, I feel more confident in the reliability of the ProductRepository class. It's comforting to know that the core functionalities are behaving as expected. Ideally, the number of unit tests in a class should be sufficient to cover all possible execution paths and edge cases. There's no magic number; it depends on the complexity of the class. While I've tried to test the common scenarios, I recognize that more tests could be added to cover cases like invalid productId values or potential exceptions. Even with 100% code coverage, bugs and errors can still exist! Code coverage only measures which lines of code have been executed, not whether the tests are actually verifying the correctness of the logic within those lines. For example, a test could execute a line of code without properly asserting the expected outcome, thus missing a bug.

## Suppose that after writing the CreateProductFunctionalTest.java along with the corresponding test case, you were asked to create another functional test suite that verifies the number of items in the product list. You decided to create a new Java class similar to the prior functional test suites with the same setup procedures and instance variables. What do you think about the cleanliness of the code of the new functional test suite? Will the new code reduce the code quality? Identify the potential clean code issues, explain the reasons, and suggest possible improvements to make the code cleaner!

Creating a new Java class that duplicates setup procedures and instance variables from CreateProductFunctionalTest.java to verify the number of items in the product list would significantly reduce code quality. The most glaring clean code violation is duplication. Having redundant setup code makes the project harder to maintain; if the setup logic needs to change, you have to update it in multiple places, increasing the risk of errors and inconsistencies. Another issue is reduced readability. The new test class would be longer and more complex than necessary, making it harder to understand the core purpose of each test. A better approach would be to create a base class or abstract class containing the common setup procedures and instance variables. The original CreateProductFunctionalTest.java and the new class for verifying item counts could then inherit from this base class, eliminating duplication and promoting code reuse. This also allows for easier extension; future functional tests could also inherit from the same base, maintaining a clean and organized test suite. We should aim for reducing code duplication because when we have 2 different function that does almost the same, it would be harder to maintain and if the code is inconsistent, the system would be harder to trace in case of an exception/error.